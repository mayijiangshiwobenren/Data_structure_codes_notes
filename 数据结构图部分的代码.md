邻接矩阵的定义

```C
//邻接矩阵结构型定义
typedef struct //顶点定义 
{
	int no;//顶点编号 
	char info;//顶点其他信息 
 } VertexType;


typedef struct//图的定义 
{
	int edges[maxSize][maxSize];//邻接矩阵定义，有权图则int改成float 
	int n,e;//存放顶点数和边数 
	VertexType vex[maxSize];//存放节点信息 
}MGraph; 
```

邻接矩阵的存储结构定义：

```C

//邻接表存储定义
typedef struct ArcNode
{
	int adjvex;//该边所指向的节点的位置 
	struct ArcNode *nextarc;//指向下一条边的指针 
	int info;//该边的相关信息 
 }ArcNode;
 
typedef struct
{
	char data;
	ArcNode *firstarc;//指向第1条边的指针 
}VNode;

typedef struct
{
	VNode adjlist[maxSize];
	int n,e;
 }AGraph;
```

图的遍历算法：

深度优先搜索遍历：类似于二叉树的**先序遍历**

下面是邻接表存储结构的DFS算法：

```C
int visit[maxSize];  
//v作为起点编号，visit存储顶点的访问标记，初始状态均为0，代表全部没有被访问过 
void DFS(AGraph *G,int v){
	ArcNode *p;
	visit[v]=1;//先把开始的节点置为已经访问过 
	Visit(v);//Visit函数是一种访问节点v的操作，此操作类比树的遍历根节点操作
	p=G->adjlist[v]. firstarc;//p指向顶点v的第一条边 
	while(p!=NULL)//while循环内部内容也可以类比树的先序遍历，树是递归遍历两个分支，这是递归遍历多个分支
	{
		if(visit[p->adjvex]==0)//若这条边所连接的节点未访问，则访问它
			DFS(G,p->adjvex);//递归调用
			p=p->nextarc;//p指向顶点v下一条边的终点 
	}
}

```

广度优先搜索遍历：

类似于树的**层次遍历**

```C
void BFS(AGraph *G,int v,int visit[maxSize])
{
	ArcNode *p;
	int que[maxSize],front=0,rear=0;//队列简单定义 
	int j;
	Visit(v);//Visit是包含访问节点操作的函数 
	visit[v]=1;
	rear = (rear+1)%maxSize;//将当前顶点v入队 
	que[rear]=v;
	while(front!=rear)//当队列非空的时候 
	{
		front=(front+1)%maxSize;
		j=que[front];
		p=G->adjlist[j].firstarc;//p指向出队顶点j的第一条边 
		while(p!=NULL)//将p所有邻接节点没有被访问的入队 
		{
			if(visit[p->adjvex]==0)//当前邻接顶点未被访问，则进队 
				{
					Visit(p->adjvex);
					visit[p->adjvex]=1;
					rear=(rear+1)%maxSize;//将邻接节点入队 
					que[rear]=p->adjvex;
				}
			p=p->nextarc;//p指向j的下一条边 
		}
	 } 	
}
```

上面两者直接调用都只局限于连通图，如果是非连通图：则挨个顶点依次遍历

```C
void dfs(AGraph *g)
{
	int i;
	for(i=0;i<g->n;++i)
	{
		if(visit[i]==0)
			DFS(g,i);
	}
}

//广度优先遍历同理
void bfs(AGraph *g)
{
	int i;
	for(i=0;i<g->n;++i)
	{
		if(visit[i]==0)
			DFS(g,i,visit);
	}
}
```

