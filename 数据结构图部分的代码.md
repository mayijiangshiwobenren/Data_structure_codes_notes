邻接矩阵的存储结构定义

```C
//邻接矩阵结构型定义
typedef struct //顶点定义 
{
	int no;//顶点编号 
	char info;//顶点其他信息 
 } VertexType;


typedef struct//图的定义 
{
	int edges[maxSize][maxSize];//邻接矩阵定义，有权图则int改成float 
	int n,e;//存放顶点数和边数 
	VertexType vex[maxSize];//存放节点信息 
}MGraph; 
```

邻接表的存储结构定义：

```C

//邻接表存储定义
typedef struct ArcNode
{
	int adjvex;//该边所指向的节点的位置 
	struct ArcNode *nextarc;//指向下一条边的指针 
	int info;//该边的相关信息 
 }ArcNode;
 
typedef struct
{
	char data;
	ArcNode *firstarc;//指向第1条边的指针 
}VNode;

typedef struct
{
	VNode adjlist[maxSize];
	int n,e;
 }AGraph;
```

图的遍历算法：

深度优先搜索遍历：类似于二叉树的**先序遍历**

下面是**邻接表存储结构**的DFS算法：

```C
int visit[maxSize];  
//v作为起点编号，visit存储顶点的访问标记，初始状态均为0，代表全部没有被访问过 
void DFS(AGraph *G,int v){
	ArcNode *p;
	visit[v]=1;//先把开始的节点置为已经访问过 
	Visit(v);//Visit函数是一种访问节点v的操作，此操作类比树的遍历根节点操作
	p=G->adjlist[v]. firstarc;//p指向顶点v的第一条边 
	while(p!=NULL)//while循环内部内容也可以类比树的先序遍历，树是递归遍历两个分支，这是递归遍历多个分支
	{
		if(visit[p->adjvex]==0)//若这条边所连接的节点未访问，则访问它
			DFS(G,p->adjvex);//递归调用
			p=p->nextarc;//p指向顶点v下一条边的终点 
	}
}

```

广度优先搜索遍历：

类似于树的**层次遍历**

```C
void BFS(AGraph *G,int v,int visit[maxSize])
{
	ArcNode *p;
	int que[maxSize],front=0,rear=0;//队列简单定义 
	int j;
	Visit(v);//Visit是包含访问节点操作的函数 
	visit[v]=1;
	rear = (rear+1)%maxSize;//将当前顶点v入队 
	que[rear]=v;
	while(front!=rear)//当队列非空的时候 
	{
		front=(front+1)%maxSize;
		j=que[front];
		p=G->adjlist[j].firstarc;//p指向出队顶点j的第一条边 
		while(p!=NULL)//将p所有邻接节点没有被访问的入队 
		{
			if(visit[p->adjvex]==0)//当前邻接顶点未被访问，则进队 
				{
					Visit(p->adjvex);
					visit[p->adjvex]=1;
					rear=(rear+1)%maxSize;//将邻接节点入队 
					que[rear]=p->adjvex;
				}
			p=p->nextarc;//p指向j的下一条边 
		}
	 } 	
}
```

上面两者直接调用都只局限于连通图，如果是非连通图：则挨个顶点依次遍历

```C
void dfs(AGraph *g)
{
	int i;
	for(i=0;i<g->n;++i)
	{
		if(visit[i]==0)
			DFS(g,i);
	}
}

//广度优先遍历同理
void bfs(AGraph *g)
{
	int i;
	for(i=0;i<g->n;++i)
	{
		if(visit[i]==0)
			DFS(g,i,visit);
	}
}
```

例：设计算法求不带权无向连接图G中距离顶点v最远的一个顶点（到v路径长度最长）

```C
//广度优先遍历最后一个节点必然距离给定节点最远-->原因： BFS是逐层访问图的，先访问近的，再访问远的

int BFS(AGraph *g,int v)
{
	ArcNode *p;
	int que[maxSize],front=0,rear=0;
	int visit[maxSize];
	int i,j;
	for(i=0;i<g->n;++i)
		visit[i]=0;
	rear=(rear+1)%maxSize;
	que[rear]=v;
	visit[v]=1;
	while(front!=rear)
	{
		front=(front+1)%maxSizze;
		j=que[front];
		p=g->adjlist[j].firstarc;
		while(p!=NULL)
		{
			if(visit[p->adjvex]==0)
			{
				visit[p->adjvex]=1;
				rear=(rear+1)%rear;
				que[rear]=p->adjvex;
			}
			p=p->nextarc;
		 } 
	}
	return j;//队列全部出队之后，j保留最后一个节点 
 } 
```

例子：设计算法，判断无向图G是否为树。若为树，返回1；否则返回0

```C
//判断无向图是一棵树的条件——有n-1条边的连通图，n为节点数目-->统计边数和节点数，判断是否符合这个公式 

void DFS2(AGraph *g,int v,int &vn,int &en)//vn用来统计图的总结点数，en用来统计边数,用DFS算法实现遍历统计 
{
	ArcNode *p;
	visit[v]=1;
	++vn;
	p=g->adjlist[v].firstarc;
	while(p!=NULL)
	{
		++en;
		if(visit[p->adjvex]==0)
			DFS2(g,p->adjvex,vn,en);
		p=p->nextarc;
	}
 } 
 
int GisTree(AGraph *g)
{
	int vn=0,en=0,i;
	for(i=0;i<g->n;++i)
	{
		visit[i]=0;
	}
	DFS2(g,1,vn,en);
	if(vn==g->n&&(g->n-1)==en/2)
	//必须要访问的节点数等于图的总结点数，同时边数等于节点数减1	,此时为树，返回1 
		return 1;
	else
		return 0;
}
```

例子：图采用邻接表存储，设计算法判别顶点i和j是否有路径

```C
int DFSTrave(AGraph *G,int i,int j){
	int k;
	for(k=0;k<G->n;++k)//先初始化visit数组 
		visit[k]=0;
	DFS(G,i);//使用DFS算法从i节点开始遍历 
	if(visit[j]==1)//如果遍历完之后发现能访问到j，说明存在路径 
		 return 1;
	else
		return 0;
} 
```

